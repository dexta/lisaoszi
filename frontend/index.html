<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>lisa oszi</title>
  <link rel="stylesheet" href="">
</head>

<body onload="init()">
<style type="text/css">
  body {
    margin: 0;
    padding: 0;
    background-color: #DEDEDE;
  }
  canvas {
    position: absolute;
    margin: 0;
    padding: 0;
    top:0;
    left:0;
  }
</style>

<canvas id="gameCanvas"></canvas>

<script type="text/javascript">
  const gameCanvas = document.getElementById("gameCanvas");
  const ctx = gameCanvas.getContext("2d");

  let HEIGHT = gameCanvas.height;
  let WIDTH = gameCanvas.width;

  let ROWS = 2;
  let COLS = 15;

  let HORIZONTAL_CIRCLES = [];
  let VERTICAL_CIRCLES = [];
  let BOX_GRID = [];
  let TICK = 0;
  let START = true;
  let RUNID = 0;

  const init = () => {
    calcCanvas();
    let sx = 110;
    let sy = 110;
    let sr = 50;
    for(let bx=0;bx<=ROWS;bx++) {
      BOX_GRID[bx] = [];
      for(let by=0;by<=COLS;by++) {
        if(by===0&&bx===0) {
          BOX_GRID[bx][by] = false;
          continue;
        } else if(by===0&&bx>0) {
          BOX_GRID[bx][by] = new circleCorner(sx*(by+1)-sr,sy*(bx+1)-sr,sr);
          BOX_GRID[bx][by].isHorizontal = false;
          BOX_GRID[bx][by].speed = 0.0051*(bx+1);
        } else if(bx===0&&by>0) {
          BOX_GRID[bx][by] = new circleCorner(sx*(by+1)-sr,sy*(bx+1)-sr,sr);
          BOX_GRID[bx][by].speed = 0.0051*(by+1);
        } else {
          BOX_GRID[bx][by] = new littleCanvas(sx*(by+1)-sr,sy*(bx+1)-sr,sr*2);
          BOX_GRID[bx][by].extAxesObjX = BOX_GRID[0][by];
          BOX_GRID[bx][by].extAxesObjY = BOX_GRID[bx][0];
        }

        BOX_GRID[bx][by].draw();
      }
    }
    BOX_GRID[0][0] = new infoText(sx-sr,sy-sr,sr);
    BOX_GRID[0][0].gridText = ROWS*COLS;
    BOX_GRID[0][0].pointCountObj = BOX_GRID[ROWS][COLS];

    // RUNID = setInterval(draw, 1000/60 );
    draw();
  };

  const draw = () => {
    TICK++;
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.strokeStyle = '#000';
    ctx.lineWidth ="3";
    ctx.strokeRect(0, 0, WIDTH, HEIGHT);

    for(let y=0;y<=ROWS;y++) {
      for(let x=0;x<=COLS;x++) {
        if(!BOX_GRID[y][x]) continue;
        BOX_GRID[y][x].draw();
      }
    }
    if(START) window.requestAnimationFrame(draw);
  };

  const calcCanvas = () => {
    gameCanvas.height = Math.floor( window.innerHeight / 100 )*100;
    gameCanvas.width = Math.floor( window.innerWidth / 100 )*100;  
    HEIGHT = gameCanvas.height;
    WIDTH = gameCanvas.width;
  };

  class canvasObj {
    constructor(x,y,r) {
      this.X = x;
      this.Y = y;
      this.radius = r;
    }
  }

  class circleCorner extends canvasObj {
    constructor(x,y,r) {
      super(x,y,r);
      this.angle = 90;
      this.speed = -.01;
      this.pointOnCX = 0;
      this.pointOnCY = 0;
      this.isHorizontal = true;
      this.circleOutlineColor = '#003300';
      this.circleDotColor = '#000000';
      this.circleDotRadius = 5;
      this.circleDotLine = 2;
      this.projLineColor = 'rgba(42,23,42,.2)';
      this.projLineWidth = 1;
    }

    set setIsHorizontal(newVal) {
      this.isHorizontal = newVal;
    }

    set setAngle(newAngle) {
      this.angle = newAngle;
    }

    get getAngle() {
      return this.angle;
    }

    draw() {
      this.pointOnCX = this.X + this.radius * Math.sin(this.angle);
      this.pointOnCY = this.Y + this.radius * Math.cos(this.angle);
      this.angle = this.angle + this.speed;

      // Outline Circle
      ctx.beginPath();
      ctx.lineWidth = "1";
      ctx.strokeStyle = this.circleOutlineColor;
      ctx.arc(this.X, this.Y, this.radius, 0, 2 * Math.PI, false);
      ctx.stroke();

      // Dot on the Circle outline
      ctx.beginPath();
      ctx.lineWidth = this.circleDotLine;
      ctx.strokeStyle = this.circleDotColor;
      ctx.arc(this.pointOnCX, this.pointOnCY, this.circleDotRadius , 0, 2 * Math.PI, false);
      ctx.fillStyle = this.circleDotColor;
      ctx.fill();
      ctx.stroke();

      // projected line to the other side
      ctx.beginPath();
      ctx.strokeStyle = this.projLineColor;
      ctx.lineWidth = this.projLineWidth;
      ctx.moveTo(this.pointOnCX,this.pointOnCY);
      if(this.isHorizontal) {
        ctx.lineTo(this.pointOnCX,HEIGHT);
      } else {
        ctx.lineTo(WIDTH,this.pointOnCY);
      }
      ctx.stroke();
    };
  }


  class littleCanvas extends canvasObj {
    constructor(x,y,r) {
      super(x,y,r);
      this.extAxesObjX = {};
      this.extAxesObjY = {};
      this.dotLineList = [];
      this.boxOutlineColor = "rgba(42,42,42,0.5)";
      this.boxOutlineStroke = 1;
      this.dotDotColor = 42;
    }

    manageList (x,y) {
      let dLen = this.dotLineList.length;
      if(dLen>1500) {
        console.log("collect your carbage");
        this.dotLineList = this.dotLineList.slice(100);
        let oldLen = dLen;
        dLen = this.dotLineList.length;
        console.log(`Length before ${oldLen} and after ${dLen}`);
        
      }
      this.dotLineList.push([Math.floor(y),Math.floor(x)]);
      // let canvasData = ctx.getImageData(0, 0, WIDTH, HEIGHT);
      ctx.beginPath();
      for(let d=0;d<=dLen;d++) {
        ctx.arc(this.dotLineList[d][0],this.dotLineList[d][1],1,2 * Math.PI, false);
        // let ty = Math.floor(this.dotLineList[d][0]);
        // let tx = Math.floor(this.dotLineList[d][1]);
        // let index = (ty + tx * WIDTH ) * 4;
        // canvasData.data[index + 0] = this.dotDotColor;
        // canvasData.data[index + 1] = this.dotDotColor;
        // canvasData.data[index + 2] = this.dotDotColor;
        // canvasData.data[index + 3] = 255; // alpha channel

      }
      ctx.stroke();
      // ctx.putImageData(canvasData, 0, 0);
    }

    draw() {
      ctx.beginPath();
      ctx.strokeStyle = this.boxOutlineColor;
      ctx.lineWidth = this.boxOutlineStroke;
      let x1 = this.X-(this.radius/2);
      let y1 = this.Y-(this.radius/2);
      
      ctx.strokeRect(x1, y1, this.radius, this.radius);
      ctx.stroke();

      this.manageList(this.extAxesObjY.pointOnCY,this.extAxesObjX.pointOnCX);
      ctx.beginPath();
      ctx.strokeStyle = "red";
      ctx.lineWidth = "1";
      ctx.arc(this.extAxesObjX.pointOnCX,this.extAxesObjY.pointOnCY , 5 ,2 * Math.PI, false)
      ctx.stroke();
    }
  }

  class infoText extends canvasObj {
    constructor(x,y,r) {
      super(x,y,r);
      this.font = 'bold 23px serif';
      this.gridText = '';
      this.pointCountObj = {};

    }

    draw() {
      ctx.font = this.font;
      // ctx.fillText(this.gridText, this.X-(this.radius*.9), this.Y-(this.radius*.9));
      let pCount = this.pointCountObj.dotLineList.length;
      let sumPointCount = pCount * this.gridText;
      ctx.fillText(pCount, this.X-(this.radius*.9), this.Y - (this.radius*.2));
      ctx.fillText(sumPointCount, this.X-(this.radius*.9), this.Y + (this.radius*.9));
      ctx.font = 'italic 16px serif';
      ctx.fillText("Point p Canvas", this.X-(this.radius*.9), this.Y - (this.radius*.7));
      ctx.fillText("Sum Points", this.X-(this.radius*.9), this.Y + (this.radius*.5));
    }
  }
</script>

</body>
</html>